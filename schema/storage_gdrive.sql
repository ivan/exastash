-- G Suite domains

CREATE TABLE gsuite_domains (
    id      smallint  GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY CHECK (id >= 1),
    domain  text      NOT NULL CHECK (domain ~ '\A.{1,255}\Z')
);

CREATE UNIQUE INDEX gsuite_domains_domain_index ON gsuite_domains (domain);

CREATE TRIGGER gsuite_domains_check_update
    BEFORE UPDATE ON gsuite_domains
    FOR EACH ROW
    WHEN (OLD.id != NEW.id)
    EXECUTE FUNCTION raise_exception('cannot change id');

CREATE TRIGGER gsuite_domains_forbid_truncate
    BEFORE TRUNCATE ON gsuite_domains
    EXECUTE FUNCTION raise_exception('truncate is forbidden');



-- Owners of Google Drive files

CREATE TABLE gdrive_owners (
    id      int       GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY CHECK (id >= 1),
    domain  smallint  NOT NULL REFERENCES gsuite_domains(id),
    -- email or other identifying string
    owner   text      NOT NULL CHECK (owner ~ '\A.{1,255}\Z')
);

CREATE UNIQUE INDEX gdrive_owners_owner_index ON gdrive_owners (owner);

CREATE TRIGGER gdrive_owners_check_update
    BEFORE UPDATE ON gdrive_owners
    FOR EACH ROW
    WHEN (OLD.id != NEW.id)
    EXECUTE FUNCTION raise_exception('cannot change id');

CREATE TRIGGER gdrive_owners_forbid_truncate
    BEFORE TRUNCATE ON gdrive_owners
    EXECUTE FUNCTION raise_exception('truncate is forbidden');



-- Google Drive files

-- Columns are ordered for optimal packing, be careful
CREATE TABLE gdrive_files (
    -- Not a UUID, just using uuid as a 128-bit field instead of bytea to save one byte
    md5          uuid         NOT NULL,
    size         bigint       NOT NULL CHECK (size >= 1),
    last_probed  timestamptz,
    -- crc32c is actually unsigned, but use an int instead of bytea to save one byte
    crc32c       int          NOT NULL,
    -- Can be NULL because some of our old chunks have no recorded owner
    owner        int          REFERENCES gdrive_owners,
    -- The shortest gdrive_id we have is 28
    -- The longest gdrive_id we have is 33, but allow up to 160 in case Google changes format
    -- The regexp here should match gdrive.rs
    id           text         PRIMARY KEY CHECK (id ~ '\A[-_0-9A-Za-z]{28,160}\Z')
);

CREATE TRIGGER gdrive_files_check_update
    BEFORE UPDATE ON gdrive_files
    FOR EACH ROW
    WHEN (
        OLD.id     != NEW.id     OR
        OLD.md5    != NEW.md5    OR
        OLD.crc32c != NEW.crc32c OR
        OLD.size   != NEW.size
    )
    EXECUTE FUNCTION raise_exception('cannot change id, md5, crc32c, or size');

CREATE OR REPLACE FUNCTION gdrive_files_not_referenced() RETURNS trigger AS $$
DECLARE
    file_id_ bigint;
BEGIN
    -- TODO: make sure index is actually being used for this
    file_id_ := (SELECT file_id FROM stash.storage_gdrive WHERE gdrive_ids @> ARRAY[OLD.id] LIMIT 1);
    IF file_id_ IS NOT NULL THEN
        RAISE EXCEPTION 'gdrive_files=% is still referenced by storage_gdrive=%', OLD.id, file_id_;
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER gdrive_files_check_delete
    BEFORE DELETE ON gdrive_files
    FOR EACH ROW
    EXECUTE FUNCTION gdrive_files_not_referenced();

CREATE TRIGGER gdrive_files_forbid_truncate
    BEFORE TRUNCATE ON gdrive_files
    EXECUTE FUNCTION raise_exception('truncate is forbidden');



-- Storage (sequences of Google Drive files)

CREATE TYPE cipher AS ENUM ('AES_128_CTR', 'AES_128_GCM');

-- Columns are ordered for optimal packing, be careful
CREATE TABLE storage_gdrive (
    -- Not a UUID, just using uuid as a 128-bit field instead of bytea to save one byte
    cipher_key     uuid      NOT NULL,
    file_id        bigint    NOT NULL REFERENCES files (id),
    cipher         cipher    NOT NULL,
    gsuite_domain  smallint  NOT NULL REFERENCES gsuite_domains (id),
    -- An sequence of encrypted chunks stored in Google Drive
    --
    -- Imagine a REFERENCES on on gdrive_files (id) here; PostgreSQL 12 doesn't
    -- support it for array elements, so we have two triggers to emulate it.
    --
    -- Don't use an array of DOMAIN type here to avoid confusing rust-postgres
    gdrive_ids     text[]    NOT NULL CHECK (cardinality(gdrive_ids) >= 1),

    -- We don't need more than one of these per this triple.
    PRIMARY KEY (file_id, gsuite_domain, cipher)
);

CREATE INDEX gdrive_gdrive_ids_index ON storage_gdrive USING GIN (gdrive_ids);

CREATE OR REPLACE FUNCTION assert_files_exist_in_gdrive_files() RETURNS trigger AS $$
DECLARE
    ids text[];
    file_count integer;
BEGIN
    -- Use FOR KEY SHARE to prevent another concurrent transaction from deleting the
    -- gdrive files we're referencing from gdrive_ids.
    ids := ARRAY(SELECT id FROM stash.gdrive_files WHERE id IN (SELECT unnest(NEW.gdrive_ids)) FOR KEY SHARE);
    -- This catches not only missing gdrive_ids but also duplicate entries in NEW.gdrive_ids
    file_count := cardinality(ids);
    IF file_count != cardinality(NEW.gdrive_ids) THEN
        RAISE EXCEPTION 'gdrive_ids had % ids: % but only % of these are in gdrive_files',
            cardinality(NEW.gdrive_ids), NEW.gdrive_ids, file_count;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER storage_gdrive_check_files
    BEFORE INSERT ON storage_gdrive
    FOR EACH ROW
    EXECUTE FUNCTION assert_files_exist_in_gdrive_files();

CREATE TRIGGER storage_gdrive_check_update
    BEFORE UPDATE ON storage_gdrive
    FOR EACH ROW
    EXECUTE FUNCTION raise_exception('cannot change file_id, gsuite_domain, cipher, cipher_key, or gdrive_ids');

CREATE TRIGGER storage_gdrive_forbid_truncate
    BEFORE TRUNCATE ON storage_gdrive
    EXECUTE FUNCTION raise_exception('truncate is forbidden');



-- OAuth 2.0 application secrets used to generate OAuth 2.0 access tokens

CREATE TABLE gsuite_application_secrets (
    domain_id  smallint  PRIMARY KEY REFERENCES gsuite_domains(id),
    secret     jsonb     NOT NULL
);

CREATE TRIGGER gsuite_application_secrets_update
    BEFORE UPDATE ON gsuite_application_secrets
    FOR EACH ROW
    WHEN (OLD.domain_id != NEW.domain_id)
    EXECUTE FUNCTION raise_exception('cannot change domain_id');

CREATE TRIGGER gsuite_application_secrets_forbid_truncate
    BEFORE TRUNCATE ON gsuite_application_secrets
    EXECUTE FUNCTION raise_exception('truncate is forbidden');



-- OAuth 2.0 bearer access tokens used to create, read, and delete Google Drive files

CREATE TABLE gsuite_access_tokens (
    expires_at     timestamptz  NOT NULL,
    -- For now, we don't need more than one access token per account
    owner_id       int          PRIMARY KEY REFERENCES gdrive_owners (id),
    access_token   text         NOT NULL,
    refresh_token  text         NOT NULL
);

CREATE TRIGGER gsuite_access_tokens_update
    BEFORE UPDATE ON gsuite_access_tokens
    FOR EACH ROW
    WHEN (OLD.owner_id != NEW.owner_id)
    EXECUTE FUNCTION raise_exception('cannot change owner_id');

CREATE TRIGGER gsuite_access_tokens_forbid_truncate
    BEFORE TRUNCATE ON gsuite_access_tokens
    EXECUTE FUNCTION raise_exception('truncate is forbidden');



CREATE DOMAIN email AS text CHECK(VALUE ~ '@' AND VALUE = lower(VALUE));

-- Service accounts used to create, read, and, delete Google Drive files

CREATE TABLE gsuite_service_accounts (
    owner_id                     int    NOT NULL REFERENCES gdrive_owners(id),
    -- All fields below come directly from the .json file downloaded from Google.
    --
    -- For now, we don't need more than one service account key per service account.
    client_email                 email  PRIMARY KEY,
    client_id                    text   NOT NULL,
    project_id                   text   NOT NULL,
    private_key_id               text   NOT NULL,
    private_key                  text   NOT NULL,
    auth_uri                     text   NOT NULL,
    token_uri                    text   NOT NULL,
    auth_provider_x509_cert_url  text   NOT NULL,
    client_x509_cert_url         text   NOT NULL
);

CREATE TRIGGER gsuite_service_accounts_update
    BEFORE UPDATE ON gsuite_service_accounts
    FOR EACH ROW
    EXECUTE FUNCTION raise_exception('cannot change row');

CREATE TRIGGER gsuite_service_accounts_forbid_truncate
    BEFORE TRUNCATE ON gsuite_service_accounts
    EXECUTE FUNCTION raise_exception('truncate is forbidden');
