-- http://man7.org/linux/man-pages/man7/inode.7.html

CREATE TYPE inode_type AS ENUM ('REG', 'DIR', 'LNK');
-- text instead of bytea, see the UTF-8 rationale on linux_basename
CREATE DOMAIN symlink_pathname AS text
    -- ext4 and btrfs limit the symlink target to ~4096 bytes.
    -- xfs limits the symlink target to 1024 bytes.
    -- We follow the lower limit in case symlinks need to be copied to XFS.
    --
    -- Linux does not allow empty pathnames: https://lwn.net/Articles/551224/
    CHECK (octet_length(VALUE) >= 1 AND octet_length(VALUE) <= 1024);

CREATE DOMAIN ino AS bigint CHECK (VALUE >= 2);

-- We don't store uid, gid, and the exact mode; those can be decided and
-- changed globally by the user.
CREATE TABLE inodes (
    ino                 bigint            GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY CHECK (ino >= 2),
    type                inode_type        NOT NULL,
    size                bigint            CHECK (size >= 0),
    mtime               timespec64        NOT NULL,
    executable          boolean,
    symlink_target      symlink_pathname,
    -- '..' for DIR inodes
    -- TODO: make sure it's OK that we don't have a REFERENCES to inodes (ino) here
    directory_parent    ino,

    -- We don't track nlinks here but rather "number of dirents" (0-inf for
    -- REG/LNK, 0-1 for DIR) and, for DIR, "number of directory children".
    -- These allow us to compute nlinks for both REG/LNK (= dirents_count)
    -- and DIR (= (dirents_count == 1 ? 2 + child_dir_count : 0))
    --
    -- For any inode, a count of how many times we appear as a child in dirents
    dirents_count       int               NOT NULL DEFAULT 0 CHECK (dirents_count >= 0 AND (type != 'DIR' OR dirents_count <= 1)),
    -- For DIR inode, a count of only the _directory_ children
    child_dir_count     int               CHECK (child_dir_count >= 0),

    -- TODO: birth_time
    -- TODO: birth_machine
    -- TODO: birth_exastash_version

    CONSTRAINT only_reg_has_size                CHECK ((type != 'REG' AND size            IS NULL) OR (type = 'REG' AND size            IS NOT NULL)),
    CONSTRAINT only_reg_has_executable          CHECK ((type != 'REG' AND executable      IS NULL) OR (type = 'REG' AND executable      IS NOT NULL)),
    CONSTRAINT only_lnk_has_symlink_target      CHECK ((type != 'LNK' AND symlink_target  IS NULL) OR (type = 'LNK' AND symlink_target  IS NOT NULL)),
    CONSTRAINT only_dir_has_child_dir_count     CHECK ((type != 'DIR' AND child_dir_count IS NULL) OR (type = 'DIR' AND child_dir_count IS NOT NULL))
);
REVOKE TRUNCATE ON inodes FROM current_user;

CREATE INDEX inode_size_index  ON inodes (size);
CREATE INDEX inode_mtime_index ON inodes (mtime);

CREATE OR REPLACE FUNCTION inodes_handle_insert() RETURNS trigger AS $$
BEGIN
    IF NEW.dirents_count != 0 THEN
        RAISE EXCEPTION 'If given, dirents_count must be 0';
    END IF;
    NEW.dirents_count := 0;

    IF NEW.type = 'DIR' THEN
        IF NEW.child_dir_count != 0 THEN
            RAISE EXCEPTION 'If given, child_dir_count must be 0 when inserting a DIR';
        END IF;
        NEW.child_dir_count := 0;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER inodes_handle_insert
    BEFORE INSERT ON inodes
    FOR EACH ROW
    EXECUTE FUNCTION inodes_handle_insert();

CREATE TRIGGER inodes_check_update
    BEFORE UPDATE ON inodes
    FOR EACH ROW
    WHEN (
        OLD.ino != NEW.ino OR
        OLD.type != NEW.type OR
        OLD.symlink_target IS DISTINCT FROM NEW.symlink_target
    )
    EXECUTE FUNCTION raise_exception('cannot change ino, type, or symlink_target');

CREATE TRIGGER inodes_check_delete
    BEFORE DELETE ON inodes
    FOR EACH ROW
    WHEN (OLD.dirents_count > 0 OR OLD.ino = 2)
    EXECUTE FUNCTION raise_exception('cannot delete inode with dirents_count > 0 or ino = 2 (root DIR)');

INSERT INTO inodes (ino, type, mtime, child_dir_count) VALUES (2, 'DIR', now()::timespec64, 0);

-- inode 0 is not used by Linux filesystems (0 means NULL).
-- inode 1 is used by Linux filesystems for bad blocks information.
-- inode 2 is used directly above for /
-- Start with inode 3 for all other inodes.
ALTER TABLE inodes ALTER COLUMN ino RESTART WITH 3;

CREATE OR REPLACE FUNCTION assert_inode_is_regular_file() RETURNS trigger AS $$
DECLARE
    ino_type inode_type;
BEGIN
    ino_type := (SELECT type FROM inodes WHERE ino = NEW.ino);
    IF ino_type != 'REG' THEN
        RAISE EXCEPTION 'inode % is %, not a regular file', NEW.ino, ino_type;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
