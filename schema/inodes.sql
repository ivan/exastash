-- http://man7.org/linux/man-pages/man7/inode.7.html

CREATE TYPE inode_type AS ENUM ('REG', 'DIR', 'LNK');

-- text instead of bytea, see the UTF-8 rationale on linux_basename
CREATE DOMAIN symlink_pathname AS text
    -- ext4 and btrfs limit the symlink target to ~4096 bytes.
    -- xfs limits the symlink target to 1024 bytes.
    -- We follow the lower limit in case symlinks need to be copied to XFS.
    --
    -- Linux does not allow empty pathnames: https://lwn.net/Articles/551224/
    CHECK (octet_length(VALUE) >= 1 AND octet_length(VALUE) <= 1024);

CREATE DOMAIN ino AS bigint CHECK (VALUE >= 2);

-- We don't store uid, gid, and the exact mode; those can be decided and
-- changed globally by the user.
CREATE TABLE inodes (
    -- inode 0 is not used by Linux filesystems (0 means NULL).
    -- inode 1 is used by Linux filesystems for bad blocks information.
    -- inode 2 is used for /
    -- Start with inode 3 for all other inodes.
    ino                     bigint            GENERATED BY DEFAULT AS IDENTITY (START WITH 3) PRIMARY KEY CHECK (ino >= 2),
    type                    inode_type        NOT NULL,
    size                    bigint            CHECK (size >= 0),
    mtime                   timespec64        NOT NULL,
    executable              boolean,
    symlink_target          symlink_pathname,

    -- parent_ino is '..' for DIR inodes; this is here instead of in dirents
    -- because we may want to delete the dirent to a directory while still
    -- keeping the inode around and having a working '..'
    --
    -- parent_ino for / is /
    -- parent_ino may point to an inode that no longer exists
    parent_ino              ino               CHECK ((ino = 2 AND parent_ino = ino) OR (ino != 2 AND parent_ino != ino)),

    -- nlinks note: a directory gets its first "nlink" from the parent's dirent
    -- to it, and its second "nlink" from the "." entry in the directory.
    -- That is not how things work in our schema, but we can perfectly emulate
    -- how Linux filesystems count "nlinks".
    --
    -- We don't track nlinks here but rather "number of dirents" (0-inf for
    -- REG/LNK, 0-1 for DIR) and, for DIR, "number of directory children".
    -- These allow us to compute nlinks for both REG/LNK (= dirents_count)
    -- and DIR (= (dirents_count == 1 ? 2 + child_dir_count : 0))

    -- For any inode, a count of how many times we appear as a child in dirents
    dirents_count           int               NOT NULL CHECK (dirents_count >= 0 AND (type != 'DIR' OR dirents_count <= 1)),
    -- For DIR inode, a count of only the _directory_ children
    child_dir_count         int               CHECK (child_dir_count >= 0),

    -- When/where/with what exastash version was this inode produced?
    birth_time              timespec64        NOT NULL,
    birth_hostname          text              NOT NULL CHECK (octet_length(birth_hostname) >= 1 AND octet_length(birth_hostname) <= 253),
    birth_exastash_version  smallint          NOT NULL REFERENCES exastash_versions (version_id),

    CONSTRAINT only_reg_has_size              CHECK ((type != 'REG' AND size            IS NULL) OR (type = 'REG' AND size            IS NOT NULL)),
    CONSTRAINT only_reg_has_executable        CHECK ((type != 'REG' AND executable      IS NULL) OR (type = 'REG' AND executable      IS NOT NULL)),
    CONSTRAINT only_lnk_has_symlink_target    CHECK ((type != 'LNK' AND symlink_target  IS NULL) OR (type = 'LNK' AND symlink_target  IS NOT NULL)),
    CONSTRAINT only_dir_has_child_dir_count   CHECK ((type != 'DIR' AND child_dir_count IS NULL) OR (type = 'DIR' AND child_dir_count IS NOT NULL)),
    CONSTRAINT only_dir_has_parent_ino        CHECK ((type != 'DIR' AND parent_ino      IS NULL) OR (type = 'DIR' AND parent_ino      IS NOT NULL))
);
REVOKE TRUNCATE ON inodes FROM current_user;

CREATE INDEX inode_size_index  ON inodes (size);
CREATE INDEX inode_mtime_index ON inodes (mtime);

CREATE OR REPLACE FUNCTION inodes_handle_insert() RETURNS trigger AS $$
BEGIN
    IF NEW.dirents_count != 0 THEN
        RAISE EXCEPTION 'If given, dirents_count must be 0';
    END IF;
    NEW.dirents_count := 0;

    -- We want this to be valid at insertion time, even if the inode may later disappear
    IF NEW.parent_ino IS NOT NULL AND NEW.parent_ino != 2 THEN
        IF (SELECT COUNT(ino) FROM inodes WHERE ino = NEW.parent_ino) = 0 THEN
            RAISE EXCEPTION 'parent_ino=% does not exist', NEW.parent_ino;
        END IF;
    END IF;

    IF NEW.type = 'DIR' THEN
        IF NEW.child_dir_count != 0 THEN
            RAISE EXCEPTION 'If given, child_dir_count must be 0 when inserting a DIR';
        END IF;
        NEW.child_dir_count := 0;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER inodes_handle_insert
    BEFORE INSERT ON inodes
    FOR EACH ROW
    EXECUTE FUNCTION inodes_handle_insert();

CREATE TRIGGER inodes_check_update
    BEFORE UPDATE ON inodes
    FOR EACH ROW
    WHEN (
        OLD.ino != NEW.ino OR
        OLD.type != NEW.type OR
        OLD.symlink_target IS DISTINCT FROM NEW.symlink_target
    )
    EXECUTE FUNCTION raise_exception('cannot change ino, type, or symlink_target');

CREATE TRIGGER inodes_check_delete
    BEFORE DELETE ON inodes
    FOR EACH ROW
    WHEN (OLD.dirents_count > 0 OR OLD.ino = 2)
    EXECUTE FUNCTION raise_exception('cannot delete inode with dirents_count > 0 or ino = 2 (root DIR)');

CREATE PROCEDURE create_root_inode(hostname text, exastash_version integer)
LANGUAGE SQL
AS $$
    INSERT INTO inodes (ino, type, mtime, parent_ino, birth_time, birth_hostname, birth_exastash_version)
        VALUES (2, 'DIR', now()::timespec64, 2, now()::timespec64, hostname, exastash_version);
$$;

CREATE OR REPLACE FUNCTION assert_inode_is_regular_file() RETURNS trigger AS $$
DECLARE
    ino_type inode_type;
BEGIN
    ino_type := (SELECT type FROM inodes WHERE ino = NEW.ino);
    IF ino_type != 'REG' THEN
        RAISE EXCEPTION 'inode % is %, not a regular file', NEW.ino, ino_type;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
