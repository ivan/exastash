diff --git a/Cargo.toml b/Cargo.toml
index ebf540f..5730b45 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -13,8 +13,14 @@ num = "*"
 docopt = "*"
 rustc-serialize = "*"
 toml = "*"
+# Note: also include Cargo license in our LICENSE bundle;
+# we copied some Toml handling code from Cargo
 
 [dependencies.mysql]
 mysql = "*"
 default-features = false
 features = ["socket"]
+
+[dependencies.xdg]
+xdg = "*"
+git = "https://github.com/whitequark/rust-xdg"
diff --git a/src/main.rs b/src/main.rs
index 43617b1..d8d3749 100644
--- a/src/main.rs
+++ b/src/main.rs
@@ -1,12 +1,15 @@
 extern crate rustc_serialize;
 extern crate docopt;
 extern crate toml;
+extern crate xdg;
 
 use docopt::Docopt;
 use std::error::Error;
 use std::fs::File;
 use std::io::Read;
-use rustc_serialize::serialize::Decodable;
+use rustc_serialize::Decodable;
+//use errors::{human, TerastashResult};
+use self::errors::{human, Human, TerastashResult};
 
 const USAGE: &'static str = "
 terastash
@@ -36,16 +39,47 @@ struct Stash {
 
 #[derive(Debug, RustcDecodable)]
 struct Config {
-	stashes: Vec<Stash>
+	stash: Vec<Stash>
 }
 
-fn get_config() -> Result<Config, Box<Error>> {
-	let mut config_file = try!(File::open("/home/at/.config/rs-terastash.toml"));
+// License: Cargo
+pub fn parse(toml: &str, file: &Path) -> CargoResult<toml::Table> {
+	let mut parser = toml::Parser::new(&toml);
+	match parser.parse() {
+		Some(toml) => return Ok(toml),
+		None => {}
+	}
+	let mut error_str = format!("could not parse input as TOML\n");
+	for error in parser.errors.iter() {
+		let (loline, locol) = parser.to_linecol(error.lo);
+		let (hiline, hicol) = parser.to_linecol(error.hi);
+		error_str.push_str(&format!("{}:{}:{}{} {}\n",
+			file.display(),
+			loline + 1, locol + 1,
+			if loline != hiline || locol != hicol {
+				format!("-{}:{}", hiline + 1,
+					hicol + 1)
+			} else {
+				"".to_string()
+			},
+			error.desc));
+	}
+	Err(human(error_str))
+}
+
+fn get_config() -> TerastashResult<Config> {
+	let xdg_dirs = xdg::BaseDirectories::with_prefix("rs-terastash");
+	let config_path = xdg_dirs.place_config_file("config.toml")
+		.expect("cannot create configuration directory");
+	let mut config_file = try!(File::open(config_path));
 	let mut config_content = String::new();
 	try!(config_file.read_to_string(&mut config_content));
-	let mut parser = toml::Parser::new(&config_content);
-	let toml = parser.parse().unwrap();
-	let mut decoder = toml::Decoder::new(toml);
+	let root = try!(parse(&config_content, &config_file));
+	//let root = try!(parser.parse().map_err(|e| {
+	//	Error::new(format!("Failed to parse TOML in {:?}: {:?}", config_path, parser.errors))
+	//}));
+	//println!("{:?}", root);
+	let mut decoder = toml::Decoder::new(toml::Value::Table(root));
 	let config = try!(Config::decode(&mut decoder));
 	Ok(config)
 }
@@ -55,5 +89,6 @@ fn main() {
 		.and_then(|d| d.decode())
 		.unwrap_or_else(|e| e.exit());
 	println!("{:?}", args);
-	get_config()
+	let config = get_config();
+	println!("{:?}", config);
 }
